# is-tech

# Lab-1

## Изучение синтаксиса языка Java и нового окружения.

В рамках лабораторной следует переписать [лабораторную работу №4](https://ronimizy.notion.site/Labs-7375b5d241c347d18616deaeeee2bc48) из прошлого семестра. 
 
# Lab-2
 
## Подготовка базы данных.
 
Необходимо создать таблицы БД по примерам, указанным в [приложении А](#Приложение-А).

Нужно подготовить скрипт DDL, который описывает создание базы данных и таблиц, используемых в этой лабораторной.

## JDBC

Реализовать подключение к БД посредством JDBC (Java DataBase Connectivity). 

Согласно интерфейсу, реализовать методы ниже для обеих таблиц базы данных (где T – это имя вашей сущности): 

```
public T save(T entity);
public void deleteById(long id);
public void deleteByEntity(T entity);
public void deleteAll();
public T update(T entity);
public T getById(long id);
public List<T> getAll();
```

Также необходимо реализовать метод, который возвращает все дочерние сущности по идентификатору родительской:

```
public List<T> getAllByVId(); // Здесь T – это дочерняя сущность, V – родительская.
```

## Hibernate

Реализовать подключение к БД посредством Hibernate - популярное ORM – решение для Java. 

Согласно интерфейсу, реализовать методы ниже для обеих таблиц базы данных (где T – это имя вашей сущности): 

```
public T save(T entity);
public void deleteById(long id);
public void deleteByEntity(T entity);
public void deleteAll();
public T update(T entity);
public T getById(long id);
public List<T> getAll();
```

Также необходимо реализовать метод, который возвращает все дочерние сущности по идентификатору родительской:
```
public List<T> getAllByVId();	// Здесь T – это дочерняя сущность, V – родительская.
```

## MyBatis

Реализовать подключение к БД посредством MyBatis – Java фреймворк для работы с сущностями БД. 

Согласно интерфейсу, реализовать методы ниже для обеих таблиц базы данных (где T – это имя вашей сущности): 

```
public T save(T entity);
public void deleteById(long id);
public void deleteByEntity(T entity);
public void deleteAll();
public T update(T entity);
public T getById(long id);
public List<T> getAll();
```

Также необходимо реализовать метод, который возвращает все дочерние сущности по идентификатору родительской:

```
public List<T> getAllByVId();		// Здесь T – это дочерняя сущность, V – родительская.
```

Для последнего метода необходимо описать условие: если дочерних сущностей больше 5, то нужно вернуть первые 5.

## Сравнение

Необходимо отправить в бд запрос на добавление 100 сущностей и сравнить время, за которое это будет выполнено всеми тремя способами. Затем отправить запрос на получение этих же самых 100 сущностей, (можно использовать метод getAll()), и также сравнить время, за которое это будет сделано тремя различными способами.


## Приложение А

*Хозяин*

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Дата рождения | Date            |

*Котик*

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Дата рождения | Date            |
| Порода        | Varchar         |
| Цвет          | Varchar         |
| Владелец      | Long            |

- В таблице «Котик» атрибут «Хозяин» является вторичным ключом для атрибута «Идентификатор» из таблицы «Хозяин»;
- Атрибуты «Идентификатор» в обеих таблицах должны быть первичными ключами;
- Атрибут «Цвет» таблицы «Котик» должен представлять из себя ограниченное количество значений: белый, рыжий, коричневый, серый, черный.
---
 
 # Lab-3

## Миграции.
Необходимо реализовать изменение схемы базы данных посредством миграций с помощью системы миграции Flyway.
Необходимо создать два скрипта миграции: 
- Первым будет являться ваш скрипт создания схемы базы данных из лабораторной №2
- Вторым изменения, которые нужно будет внести в схему, указанные в приложении А данной лабораторной.

**Важно!**

Ваши миграции должны отрабатывать, как на базе данных, в которой нет нужных вам таблиц и прочих объектов БД, так и на базе данных, в которых уже все данные есть.

## Spring Data

> **1.** Подключить к проекту Spring Data.

> **2.** Создать для уже существующих сущностей, (используемых для Hibernate), репозитории.Пример:
> ```
> public interface CarBrandRepository extends JpaRepository<Long, CarBrand> { }
> ```

> **3.** Необходимо реализовать метод, который возвращает все дочерние сущности по идентификатору родительской:
> ```
> public List<T> getAllByVId(id); // Здесь T – это дочерняя сущность, V – родительская.
> ```

> **4)** Необходимо реализовать метод, который возвращает родительские сущности по определенному значению:
> ```
> public List<T> getAllByName(name); // Здесь T – это тип сущности.
> ``` 

## Spring MVC


> **1.** Подключить к проекту Spring MVC.

> **2.** Реализовать CRUD для каждой сущности, к которому можно обратиться через HTTP. (Чтобы было проще и понятнее, почитайте про @Controller и @RestController – это аннотации Spring, позволяющие создавать объекты прослушивающие HTTP – запросы).

> **3.** Для всех созданных классов – контроллеров сделать интерфейс - Swagger.

## Приложение А.

### Хозяин

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Дата рождения | Date            |


### Котик

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Дата рождения | Date            |
| Порода        | Varchar         |
| Цвет          | Varchar         |
| $${\color{green}Длина \spaceхвоста}$$  | $${\color{green} Int}$$          |
| Владелец      | Long            |


### Блоха

| Название поля | Тип данных поля |
|---------------|-----------------|
| Идентификатор | Long            |
| Имя           | Varchar         |
| Котик         | Long            |

- В таблице «Котик» атрибут «Хозяин» является вторичным ключом для атрибута «Идентификатор» из таблицы «Хозяин»;
- Атрибуты «Идентификатор» в обеих таблицах должны быть первичными ключами;
- Атрибут «Цвет» таблицы «Котик» должен представлять из себя ограниченное количество значений: белый, рыжий, коричневый, серый, черный.
--- 
 
# Lab-4

## Владельцы недовольны, что инфрмацию о котиках может получить кто угодно. В этой лабораторной мы добавим авторизацию к сервису.

Добавляется роль администратора. Он имеет доступ ко всем методам и может создавать новых пользователей. Пользователь связан с владельцем в соотношении 1:1.

Методы по получению информации и котиках и владельцах должны быть защищены [Spring Security](https://docs.spring.io/spring-security/reference/index.html). Доступ к соотвутсвующим endpoint’ам имеют только владельцы котиков и администраторы. Доступ к методам для фильтрации имеют все авторизованные пользователи, но на выходе получают только данные о своих котиках.

**Внимание**: эндпоинты, созданные на предыдущем этапе, не должны быть удалены.
---
 
# Lab-5

## Бизнес прочитал статью о том, что микросервисы это круто и попросил нас разбить программу на микросервисы.

Из созданного приложения выделяются три микросервиса:
- Микросервис доступа к котикам.
- Микросервис доступа к владельцам.
- Микросервис с внешними интерфейсами.

Все они являются **разными приложениями**.

Все созданные ранее эндпоинты и авторизация переезжает на третий микросервис.

Общение между микросервисами происходит посредством [RabbitMQ]

Сервисы доступа к котикам и доступа к владельцам могут либо быть подключены к одной БД, либо иметь разные БД. Во втором случае недопустимо делать один запрос на получение данных из двух БД, запроса должно быть два (по одному в каждую).
